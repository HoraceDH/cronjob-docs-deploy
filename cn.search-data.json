{"/docs/about/":{"data":{"":"","#":"一、关于Cron-Job 业内已经有很多类似的调度平台，为什么我会再自研一个？主要有以下几点的考虑：\n1. 构建自己的产品 光说不练假把式，有些路自己走一遍才深有体会，考虑太多、纠结太多只会内耗而停滞不前，所以行动力、执行力很重要。 我希望有一个自己的产品，精心打磨，坚定不移的持续做下去（当然并不只做这一件事，我还想做更多其他事），并把它发扬光大，虽然这很难，但我觉得这值得尝试，最终哪怕没到预期，也是一场不错的人生体验。 让更多的用户喜欢我的产品，是我很有成就感的事情，并且我享受它给我带来的成就感。 2. 用户体验与效率 让用户的接入更加简单，只需要代码上打上注解，就可以完成自动注册，不需要额外的配置，只需要点击开始即可。 现代化的管理后台UI更加精美简洁，并优化了管理后台的交互逻辑，理解和使用更加简单（为此，我专门学了前端React相关技术）。 更加全面且有结构化的官方文档，尽可能让用户一目了然，自主接入和部署，而不需要过多研究和提问。 3. 增强横向扩展能力 多租户的接入能力，只需要部署一套调度平台，即可接入公司内所有业务线。 横向扩展的能力，支持集群多节点部署，即可支持更大的并发量和任务量。 4. 毫秒级的调度延迟 基于提前调度策略，抹平服务器时间差、网络延迟等因素，使任务的执行更加及时，实际测试为个位数毫秒级别（执行器的GC和性能）。 基于ACK确认、失败重试、过期调度等策略，使任务的执行更加准确、可靠，当然也可以通过配置不要失败重试。 5. 管理后台的安全性 精心设计权限管理的功能，可控制到接口的权限级别，任务的安全性更加可靠，多租户间权限隔离。 后台管理接口的交互、执行器和调度器之间的openApi交互，均采用签名校验机制，避免参数篡改、伪造和重放等问题。 6. 问题的排查效率 管理后台提供更多维度的日志详情，能够帮助用户更好的理解任务的执行情况，并且能够更好的排查问题。 二、关于提问 我很乐意分享和交流探讨，但提问之前请先看文档或者日志，并经过思考之后提出有意义的问题。 如果你准备提出“为什么不行“，”昨天还好好的“，诸如此类毫无意义的问题，我可能不会理你。 提问前最好带上具体场景、错误日志等相关信息，以便更好解决你的问题。 另外，学会提问是一项重要的能力，与编码能力同等重要，都是属于解决问题的能力。 三、关于作者 毕业于移动应用开发专业，没正经做过移动开发工作，但很多年前赚到过一份接Android外包的钱😂。 工作10年+，毕业后一直做服务端相关工作，经历过初创公司和国内大厂，目前就职于国内某上市互联网企业。 经历过百万日活的高并发项目，踩过的坑都积累成了自己的经验。 做过3年以上技术管理，带过30人成熟技术团队，也从0到1组建过初创团队。 喜欢折腾技术，但不是死磕，产品能力和解决问题能力很重要，技术只是其中一环而已。 也喜欢”带队打仗“，带领团队一起完成项目，是我很有成就感的事情，如果还是一帮志同道合的人，那会让我很兴奋。 四、联系我(注明来意) 邮箱：Horace_DH@163.com。 微信：Horace_2020，加我备注\"Cron-Job\" "},"title":"关于"},"/docs/arch/executor-arch/":{"data":{"":"","#":"一、概述 执行器SDK是整个分布式任务调度平台中，接收调度中心派发的任务请求，并执行任务的模块，使用方需要接入执行器SDK，实现任务执行的逻辑。它主要包含以下功能：\n接收调度中心派发的任务请求。 任务缓存到内存队列，并在指定时间执行任务。 OpenApi接口交互签名与验签。 上报任务的执行结果。 执行器心跳上报，每3秒一次心跳，表明执行器在线。 执行器与任务的自动注册，每30s自动注册一次。 二、整体架构 1. 模块架构 三、核心模块设计 1. 提前调度 任务会提前3秒（可配置）被调度器派发到执行器，执行器接收到任务后，会将任务添加到延迟队列中，延迟队列会在任务的执行时间到达后，将任务派发到执行线程池中执行。 这样设计的目的是为了提高任务执行的及时性，能够有效的规避因为网络延迟、调度延迟等各种原因导致任务执行时间滞后。\n2. 自动注册 执行器启动时，会自动注册执行器和任务信息到调度器中，只需要在管理后台启动任务即可使用，不需要手动在管理后台配置信息。启动时会先注册执行器再注册任务信息，之后每30秒会自动注册一次，以确保信息的及时同步到调度器，其中已经存在的任务信息不会被覆盖， 也就是说，管理后台中修改过的信息，自动注册机制不会去影响，它只在第一次有效。 执行器的自动注册依赖于三个方面的元数据信息：\n执行器的配置信息： 对于原生Java版本：需要手动通过代码配置。 对于SpringBoot版本：可以通过Spring的配置文件配置，也可以通过Bean来实例化对象cn.horace.cronjob.executor.starter.config.ExecutorStarterConfig。 预定义的任务对象： 对于原生Java版本：需要手动实例化对象，并设置到执行器的配置中。 对于SpringBoot版本：只需要将任务类交给Spring容器管理即可，不需要手动实例化对象。 注解标识的任务信息：任务的配置信息由cn.horace.cronjob.executor.annotation.TaskConfig注解来配置决定，它需要放在任务类上，使用时按需修改其中各项配置即可。 3. 线程池 执行器中，总共有三个关键的线程池，分别是：\n调度线程池，核心线程数为3个，用在3秒一次的心跳和30秒一次的自动注册。 执行线程池，用于执行实际的任务，核心线程数为5个，最大80个，空闲5分钟后销毁。 结果上报线程池，用于上报任务结果，核心线程数为5个，最大80个，空闲5分钟后销毁。 执行线程池和结果上报线程池分开的目的是为了避免相互影响，而且控制了核心线程数，开销并不大。另一个值得一提的是任务的派发，这里是固定一个线程永不停歇的从延迟队列获取任务，如果没有任务，那么线程会阻塞，直到有任务到达或者超时，直到下一轮， 这里不需要线程池的原因是一个线程就能满足，拿到任务后就会派发给执行线程执行，所以它的开销很小。\n4. 优雅下线 优雅下线的设计目的是为了执行器关闭时可以做好收尾工作，规避因关闭、重启导致数据丢失和不一致性的问题。简单来说，在执行器关闭时，会有以下的行为：\n向调度器发送下线请求。 停止接收任务的派发 停止心跳。 停止自动注册。 等待现有任务执行完毕。 等待结果上报线程池中的任务执行完毕。 为了达到上述的效果，避免收到关闭命令时，网络通道等相关资源已关闭，执行器SDK修改了ShutdownHook的默认行为，优雅下线的动作会先于系统默认的hook执行，因此确保关闭前所依赖的资源可用。细节可查看源码cn.horace.cronjob.commons.utils.shutdown.ShutdownHookManager。\n5. 定期心跳 定期心跳的目的是为了能够上报执行器的状态，以便于调度器能够及时的感知到执行器的存在，从而能够及时的进行任务的调度。如果执行器超过30秒没有心跳，则会置为下线状态，不会再派发任务。另外结合优雅关闭，执行器关闭时，会主动下线自己，以便调度器及时感知。\n6. 安全性设计 执行器与调度器之间的交互接口，均采用签名校验的方式，以保证数据的安全性。签名秘钥由调度器的配置决定，执行器需要保持一致。接入方在接入时，可以按需自定义，以免和大众一样，签名验证算法简要概括如下：\n发送端将待签名参数按照参数名称的字典序排序。 将排序后的参数按照key=value的格式拼接成一个字符串。 将拼接后的字符串和秘钥进行MD5加密。 将加密后的MD5值作为签名参数，添加到请求参数中。 接收端将请求参数中的签名参数取出，按照相同的算法进行签名。 将签名后的MD5值与请求参数中的签名参数进行比较，如果一致，则认为请求是合法的。 详情可查阅签名工具类cn.horace.cronjob.commons.utils.SignUtils。"},"title":"执行器的设计"},"/docs/arch/scheduler-arch/":{"data":{"":"","#":"一、概述 调度器是系统中负责任务调度的服务，它根据任务的配置信息，在指定的时间点派发任务给执行器，它负责管理和调度系统中的所有任务。\n二、整体架构 1. 模块架构 2. 部署架构 3. 调度器的依赖 调度器仅依赖于MySQL数据库，除此之外不依赖于任何第三方服务，部署成本低。\n三、核心模块设计 1. 多租户的设计 多租户的设计目的是为了实现多个业务线共享一套调度系统，每个业务线可以独立配置租户的资源和权限，实现资源的隔离和权限的控制。执行器在注册时，需要携带租户标识以标明自己所属的租户，后续可在管理平台做权限的管控。 对于含有多区域业务系统的企业，例如国内多条业务线、海外多条业务线，建议每个区域部署一套独立的调度平台，因为跨区、跨州的网络通信不确定性较大。 2. 调度器的管理 调度器支持集群的部署，保障高可用的同时，还实现了负载均衡的效果，当调度任务量大、应用规模大的时候，建议多几个节点。为了保证最小高可用，建议至少部署2个节点。 多节点部署时需要修改服务ID，在配置文件application.properties中配置server.id，需要确保每个节点ID是唯一的，另外需要检查server.port是否被占用，如果你把多个节点部署到同一台机器的话。但不建议这么做，因为这达不到高可用的目的。 调度器启动时会有3秒一次的心跳，用于标识自己在线，如果超过10秒没有心跳，则判定为下线，集群的调度器列表可以在管理平台上查看。 3. 执行器的管理 执行器启动时，会向调度器注册自己的信息，包括执行器的IP、端口、名称、标签、执行器的描述等元数据信息，启动后会保持3秒一次的心跳，并且每30秒会注册一次执行器元数据信息。 执行器的关闭前，会向调度器发送下线请求，下线成功后，执行器会从调度器的列表中移除，任务不会再派发给这个执行器。同时调度器会每3秒检测一次执行器的状态，如果超过10秒没有心跳，则判定为下线。 临界条件下，如果调度器派发任务给正在关闭的执行器，那么执行器会响应一个已下线的错误码，调度器会将此执行器置为下线状态，同时会重新派发任务给其他执行器。 4. 任务的管理 执行器启动时，会向调度器全量注册自己的任务信息，任务的注册机制与执行器的逻辑保持一致，启动后会保持3秒一次的心跳，并且每30秒会注册一次执行器元数据信息。 当某个任务下线时，执行器会以特定的错误码通知调度器，调度器会将此任务置为停止状态，后续将不再派发该任务给执行器，表示该任务已不再使用。 当新的迭代新增任务时，上线后可在管理平台看到任务的详细信息，但此时还未启动，需要手动启动任务，才会开始任务的调度，启动前需要确保所有的执行器都已经部署完成，避免调度时误把任务下线。 任务的注册会以租户ID、应用ID和任务类方法全限定名作为唯一标识，已经存在的任务不会被覆盖，以确保注册后可以在管理平台随意修改任务的配置信息。 5. 通信的设计 调度器与执行器之间的通信采用HTTP协议，执行器内部会启动一个基于Jetty的内嵌式Web服务，调度器也会基于Web服务开放OpenAPI接口，供执行器交互。 与长连接协议不同的是，此类场景下，HTTP协议会更加简单，实现起来也更加容易，未来支持多执行器SDK客户端时，更加简便。 6. 任务调度的设计 6.1 锁的设计 在一些锁竞争不大也不频繁的场景下，为了减少对第三方系统的依赖，系统内的分布式锁采用了MySQL来实现，主要用在定期统计数据、定期生成任务日志等场景。 其余一些互斥的场景则使用版本号的方式实现乐观锁，尽可能避免行锁。 6.2 预先生成任务日志 任务日志是任务调度的最小粒度，一个任务每一次调度都会生成一条任务日志，它会根据任务的配置信息，预先生成好未来执行的任务日志，以便于节省调度时间。任务日志的生成步骤大致如下：\n每5秒钟就检查一次是否需要生成任务日志，符合生成条件时则继续生成。 先获得分布式锁，以确保集群环境下只有一个节点在生成任务日志。 批量获取启动状态的任务，并交给线程池生成任务日志。 生成任务日志时，会预先生成3分钟内将要执行的任务，可以通过schedulers.taskPreGenerationMaxTimeMinutes修改配置，如果不是特别理解内部机制，建议不做修改。 生成好的任务日志，会处于初始化的状态，等待执行器获取到内存的调度队列中。 6.4 任务日志的状态 初始化：任务日志创建成功，等待调度器派发。 队列中：任务日志已被调度器放入内存队列，等待调度器派发给执行器执行。 调度中：任务日志已被调度器派发给执行器，等待执行器执行的结果。 执行成功：任务执行成功，任务日志已被执行器返回。 执行失败：任务执行失败，可在详情中查看详细原因。 取消执行：一般是调度前修改了任务详情，或者停止了应用，则会被取消。 任务过期：任务已经超过了调度时间，并且过期策略是丢弃，表示任务日志已被丢弃。 执行失败，已丢弃：任务执行失败，并且失败策略是丢弃，表示任务日志已被丢弃。 执行失败，重试中：表示上一次任务执行失败，正在重试中。 6.4 内存调度队列 调度器每5秒钟会从数据库获取初始化和失败重试状态的任务日志放到内存队列中，它是一个优先队列，队列的元素会按照执行时间从近到远排序，以便于任务日志的获取。 内存队列的最大容量通过schedulers.taskQueueCount控制，避免单实例内存队列过大，影响系统的整体性能和稳定性。 获取到任务日志后，会通过乐观锁的方式，将任务状态变更为队列中的状态，并等待任务到时间被调度。 6.5 任务的调度 调度器启动后，会固定一个线程不停地从内存队列获取待执行的任务日志，并检查是否达到了提前调度的条件，默认是提前3秒钟调度，可以通过schedulers.beforeInterval配置修改，默认情况下不建议修改。 当任务日志达到提前调度条件后，会将任务日志的状态变更为调度中的状态，并将任务日志提交到调度线程池，调度线程池会根据任务的预设策略派发给执行器执行。 6.6 调度策略 在任务将要派发给执行器执行时，根据预设策略会有不同的调度行为，目前支持以下几种策略：\n随机策略：从当前在线的执行器中随机选择一个执行器，如果没有在线的执行器，则会进入失败策略的处理中。 分片策略：获取所有在线的执行器，每个执行器都会派发任务，并且携带分片参数（page和total），以便于使用方做大任务的分片处理。 选定好调度策略之后，会通过通过HTTP协议调用执行器暴露的WEB服务接口，将任务派发给执行器执行。 6.7 失败策略 不管因何种原因导致的调度失败，都会进入失败策略的处理中，失败策略的处理会根据预设的策略进行处理，失败的原因可以通过管理平台的任务日志详情看，目前支持以下几种策略：\n失败后丢弃：任务执行失败，任务日志会被丢弃。 失败后重试：任务执行失败，任务日志会被重新放入内存队列，等待下次调度。 在失败重试的场景下，可以配置最大的重试次数，默认是5次，超过最大重试次数后，任务日志会被丢弃，并记录信息。\n7. 数据的清理 下线的执行器、任务的调度日志、统计的数据等，为了避免系统内数据一直无限增长，需要定期清理这些数据，避免系统内数据量过大，影响系统的性能。数据的保留时间可以通过data.maxRetainDays修改，默认保存5天。\n8. 安全性的设计 执行器与调度器之间的交互接口，均采用签名校验的方式，以保证数据的安全性。签名秘钥由调度器的配置决定，执行器需要保持一致。接入方在接入时，可以按需自定义，以免和大众一样，签名验证算法简要概括如下：\n发送端将待签名参数按照参数名称的字典序排序。 将排序后的参数按照key=value的格式拼接成一个字符串。 将拼接后的字符串和秘钥进行MD5加密。 将加密后的MD5值作为签名参数，添加到请求参数中。 接收端将请求参数中的签名参数取出，按照相同的算法进行签名。 将签名后的MD5值与请求参数中的签名参数进行比较，如果一致，则认为请求是合法的。 另外，调度器会管理两套签名秘钥，一套用于管理后台的UI交互，一套用于执行器的SDK交互，以保证安全性。如果要修改管理后台的UI秘钥，则需要自行构建一下。\n9. 权限的设计 权限支持两种维度，一种是租户级别的权限，一种是接口级别的权限，可以满足业务线权限隔离的需求，接口级别的权限，可以满足某些用户只能查看，不能编辑任务的需求，使用时可以按需开不同的权限。\n10. 调度器的优雅关闭 优雅关闭的设计目的是为了调度器关闭时可以做好收尾工作，规避因关闭、重启导致数据丢失和不一致性的问题。简单来说，在调度器关闭时，会有以下的行为：\n停止生成新的任务日志。 停止获取任务日志到内存队列。 等待所有的任务日志派发完成。 停止调度器的心跳，优雅的关闭各个线程池，等待线程池中的任务执行完成。 为了达到上述的效果，避免收到关闭命令时，网络通道、数据库连接等相关资源已关闭，调度器修改了ShutdownHook的默认行为，优雅下线的动作会先于系统默认的hook执行，因此确保关闭前所依赖的资源可用。细节可查看源码cn.horace.cronjob.commons.utils.shutdown.ShutdownHookManager。"},"title":"调度器的设计"},"/docs/deploy/cluster-deploy/":{"data":{"":"","#":"一、环境要求 OS：支持Linux、Windows、MacOS，下面以CentOS为例。 JDK：1.8+，官方用的是：1.8.0_391，64位。 MySQL：5.7+，官方用的是： 5.7.35-log Source distribution。 二、发行版下载地址 下载发行版 GitHub：https://github.com/HoraceDH/cron-job/releases Gitee：https://gitee.com/HoraceDH/cron-job/releases 解压文件，这里以gitee仓库为例，下载最新的版本，解压后会得到如下文件内容： cronjob-examples：示例代码，可直接运行 包含原生Java版本的 example-executor SpringBoot版本的 example-executor-starter cronjob-managerui：管理后台UI cronjob-scheduler：调度器，负责任务调度的服务端 mysql.sql：完整的数据库初始化脚本 三、初始化数据库 初始化SQL，找到mysql.sql文件，进入到MySQL命令行中，执行以下命令即可完成初始化，其中path替换为自己的路径： source /path/mysql.sql 成功后，会产生cron-job库，并包含如下表： 库表说明 t_app，应用信息表。 t_executor，执行器信息表。 t_locks，系统用的分布式锁表。 t_menu，菜单表。 t_role，角色表。 t_role_menu，角色和菜单的关联表。 t_scheduler_instance，调度器实例表。 t_statistics，统计信息表。 t_task，任务信息表。 t_task_log，任务日志表，一个任务的每一次调度都会有一条日志。 t_tenant，租户表。 t_token，管理后台登录的token表。 t_user，管理后台用户表。 t_user_role，用户和角色的关联表。 t_user_tenant，用户与租户的关联表。 四、调度器服务端部署 1. 部署第一台实例 1.1 修改配置文件 文件路径etc/application.properties： ############# 调度器配置 ############# # 用于标识实例的唯一性 server.id=1 ############# 调度器配置 ############# ############# 数据源配置 ############# database.url=jdbc:mysql://localhost:3306/cron-job?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=false\u0026allowPublicKeyRetrieval=true database.username=horace database.password=SGJIWkjfdsof923847 ############# 数据源配置 ############# ############# Tomcat配置 ############# # Tomcat服务配置 server.port=9527 ############# Tomcat配置 ############# 主要修改以下配置： server.id：用于标识实例的唯一性，每个实例必须唯一。 server.port：服务端口，如果在同个机器部署，则需要修改端口，保证端口不冲突。 database.url：数据库连接地址。 database.username：数据库用户名。 database.password：数据库密码。 详细的配置说明请参考：详细配置 1.2 启动第一台实例 执行命令： # 注意，请按照自身需要调整JVM参数，例如堆大小等 sh start.sh 查看日志输出，以下表示启动成功，有错则需要看日志排错，日志路径logs/app.log： 2025-02-18 17:28:24.427 INFO [background-preinit]o.h.v.i.util.Version - HV000001: Hibernate Validator 6.2.0.Final 2025-02-18 17:28:24.432 INFO [main]c.h.c.s.SchedulerMain - Starting SchedulerMain using Java 1.8.0_391 on HoraceiMacProMax.local with PID 4420 (/Users/horace/Downloads/cron-job-v1.0.1/cronjob-scheduler/cronjob-scheduler-1.0.1.jar started by horace in /Users/horace/Downloads/cron-job-v1.0.1/cronjob-scheduler) 2025-02-18 17:28:24.432 INFO [main]c.h.c.s.SchedulerMain - No active profile set, falling back to 1 default profile: \"default\" 2025-02-18 17:28:25.276 INFO [main]o.s.b.w.e.t.TomcatWebServer - Tomcat initialized with port(s): 9527 (http) 2025-02-18 17:28:25.283 INFO [main]o.a.c.h.Http11NioProtocol - Initializing ProtocolHandler [\"http-nio-9527\"] 2025-02-18 17:28:25.284 INFO [main]o.a.c.c.StandardService - Starting service [Tomcat] 2025-02-18 17:28:25.284 INFO [main]o.a.c.c.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.65] 2025-02-18 17:28:25.399 INFO [main]o.a.c.c.C.[.[.[/] - Initializing Spring embedded WebApplicationContext 2025-02-18 17:28:25.399 INFO [main]o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 932 ms 2025-02-18 17:28:25.822 INFO [main]c.a.d.p.DruidDataSource - {dataSource-1} inited 2025-02-18 17:28:26.338 INFO [main]c.h.c.s.s.i.SchedulerServiceImpl - find router strategy handler, name:randomRouterStrategyHandlerImpl, handler:cn.horace.cronjob.scheduler.strategy.RandomRouterStrategyHandlerImpl@431e86b1 2025-02-18 17:28:26.339 INFO [main]c.h.c.s.s.i.SchedulerServiceImpl - find router strategy handler, name:shardingRouterStrategyHandlerImpl, handler:cn.horace.cronjob.scheduler.strategy.ShardingRouterStrategyHandlerImpl@5f36c8e3 2025-02-18 17:28:26.430 INFO [scheduler-thread-1]c.h.c.s.s.i.StatisticsServiceImpl - start statistics, startDate:null, endDate:Tue Feb 18 17:25:00 CST 2025 2025-02-18 17:28:26.432 INFO [scheduler-thread-1]c.h.c.s.s.i.StatisticsServiceImpl - end statistics, count:0, startDate:null, endDate:Tue Feb 18 17:25:00 CST 2025 2025-02-18 17:28:26.661 INFO [main]o.a.c.h.Http11NioProtocol - Starting ProtocolHandler [\"http-nio-9527\"] 2025-02-18 17:28:26.684 INFO [main]o.s.b.w.e.t.TomcatWebServer - Tomcat started on port(s): 9527 (http) with context path '' 2025-02-18 17:28:26.693 INFO [main]c.h.c.s.SchedulerMain - Started SchedulerMain in 2.551 seconds (JVM running for 3.136) 2025-02-18 17:28:36.421 INFO [scheduler-thread-1]c.h.c.s.s.i.StatisticsServiceImpl - start statistics, startDate:null, endDate:Tue Feb 18 17:25:00 CST 2025 2025-02-18 17:28:36.423 INFO [scheduler-thread-1]c.h.c.s.s.i.StatisticsServiceImpl - end statistics, count:0, startDate:null, endDate:Tue Feb 18 17:25:00 CST 2025 2. 部署第N台实例 拷贝一份cronjob-scheduler，作为第N台实例，按照第一台实例的方式修改配置文件即可。 如若部署更多实例，按照第一台实例的做法，依次部署即可，注意修改server.id以及相关配置。 五、管理后台UI部署 1. 存放静态资源 管理后台UI可以在发布包中找到cronjob-managerui目录，将cronjob-managerui放到合适的目录下，该目录就是打包后的前端文件。\n2. Nginx配置 参照如下模板配置即可，注意修改对应的信息：\nupstream cron_job.server { # 配置多个调度器地址，用于负载均衡 server 127.0.0.1:9527; server 127.0.0.1:9528; } server { listen 80; server_name 127.0.0.1; error_log logs/127.0.0.1.error.log error; access_log logs/127.0.0.1.access.log main; # 管理后台UI静态资源 location / { # 用于配合ant.design browserHistory 使用 try_files $uri $uri/index.html /index.html; root /Users/horace/Downloads/cron-job-v1.0.1/cronjob-managerui; index index.html; } # 管理后台API接口 location /manager-api { proxy_pass http://cron_job.server; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; } # 开放API接口 location /openapi { proxy_pass http://cron_job.server; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; } } 3. 启动Nginx 访问http://127.0.0.1，实际访问地址根据自身部署的站点情况调整，实际生产部署需要配置域名。\n4. 登录任务调度平台 看到如下页面时，说明部署成功，输入账号密码 admin/admin 进入系统： 六、启动示例工程 1. 进入目录 进入cronjob-examples/example-executor目录，并执行如下命令：\nsh start.sh 2. 检查执行器日志 出现以下表示启动成功，其中cron job executor register success表示执行器注册成功，cron job task register success执行器任务注册成功。\n2025-02-18 17:59:40.855 INFO [main]c.h.c.e.s.TaskService - found cron job task, TaskConfig{tenant='horace', method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', name='普通测试任务', appName='example-executor', appDesc='普通示例执行器', tag='common', remark='', cron='* * * * * ? ', routerStrategy=1, expiredStrategy=2, expiredTime=180000, failureStrategy=2, timeout=10000, maxRetryCount=5, failureRetryInterval=5000} 2025-02-18 17:59:40.868 INFO [cron-job-http-server]o.eclipse.jetty.util.log - Logging initialized @448ms to org.eclipse.jetty.util.log.Slf4jLog 2025-02-18 17:59:40.944 INFO [cron-job-http-server]o.e.jetty.server.Server - jetty-9.4.48.v20220622; built: 2022-06-21T20:42:25.880Z; git: 6b67c5719d1f4371b33655ff2d047d24e171e49a; jvm 1.8.0_391-b13 2025-02-18 17:59:40.968 INFO [cron-job-http-server]o.e.jetty.server.session - DefaultSessionIdManager workerName=node0 2025-02-18 17:59:40.969 INFO [cron-job-http-server]o.e.jetty.server.session - No SessionScavenger set, using defaults 2025-02-18 17:59:40.970 INFO [cron-job-http-server]o.e.jetty.server.session - node0 Scavenging every 600000ms 2025-02-18 17:59:40.978 INFO [cron-job-http-server]o.e.j.s.h.ContextHandler - Started o.e.j.s.ServletContextHandler@688910fd{/,null,AVAILABLE} 2025-02-18 17:59:40.992 INFO [cron-job-http-server]o.e.j.s.AbstractConnector - Started ServerConnector@69735139{HTTP/1.1, (http/1.1)}{192.168.16.51:8527} 2025-02-18 17:59:40.992 INFO [cron-job-http-server]o.e.jetty.server.Server - Started @572ms 2025-02-18 17:59:40.992 INFO [cron-job-http-server]c.h.c.e.h.HttpServer - cron job web server started, address:192.168.16.51:8527 2025-02-18 17:59:41.343 INFO [scheduler-thread-1]c.h.c.e.s.OpenApiService - cron job executor register success, serverAddress:http://127.0.0.1, params:ExecutorRegisterParams{tenant='horace', appName='example-executor', appDesc='普通示例执行器', hostName='HoraceiMacProMax.local', tag='common', version='Java-1.0.1', address='192.168.16.51:8527'}, result:MsgObject{code=0, msg='', data=null} 2025-02-18 17:59:42.407 INFO [scheduler-thread-1]c.h.c.e.s.OpenApiService - cron job task register success, address:192.168.16.51:8527, result:MsgObject{code=0, msg='', data=null} 3. 启动任务 登录管理后台，点击任务管理，点击启动任务，即可开始任务的调度。 4. 查看调度日志 可以看到，每秒钟一次调度，很准时！\n2025-02-18 18:03:51.000 INFO [executor-task-5]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791224381441, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873031000, receivedDispatcherTime=1739873028002, params=''} 2025-02-18 18:03:52.000 INFO [executor-task-1]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791241158657, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873032000, receivedDispatcherTime=1739873029002, params=''} 2025-02-18 18:03:53.000 INFO [executor-task-2]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791257935873, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873033000, receivedDispatcherTime=1739873030005, params=''} 2025-02-18 18:03:54.000 INFO [executor-task-3]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791274713089, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873034000, receivedDispatcherTime=1739873031002, params=''} 2025-02-18 18:03:55.000 INFO [executor-task-4]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791291490305, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873035000, receivedDispatcherTime=1739873032002, params=''} 2025-02-18 18:03:56.000 INFO [executor-task-5]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791299878913, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873036000, receivedDispatcherTime=1739873033002, params=''} 2025-02-18 18:03:57.000 INFO [executor-task-1]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791308267521, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873037000, receivedDispatcherTime=1739873034002, params=''} 2025-02-18 18:03:58.000 INFO [executor-task-2]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791325044737, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873038000, receivedDispatcherTime=1739873035002, params=''} 2025-02-18 18:03:59.000 INFO [executor-task-3]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791341821953, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873039000, receivedDispatcherTime=1739873036002, params=''} 2025-02-18 18:04:00.000 INFO [executor-task-4]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791350210561, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873040000, receivedDispatcherTime=1739873037002, params=''} 2025-02-18 18:04:01.000 INFO [executor-task-5]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791358599169, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873041000, receivedDispatcherTime=1739873038002, params=''} 2025-02-18 18:04:02.000 INFO [executor-task-1]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791366987777, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873042000, receivedDispatcherTime=1739873039002, params=''} 2025-02-18 18:04:03.000 INFO [executor-task-2]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791375376385, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873043000, receivedDispatcherTime=1739873040002, params=''} 2025-02-18 18:04:04.000 INFO [executor-task-3]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791383764993, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873044000, receivedDispatcherTime=1739873041002, params=''} 2025-02-18 18:04:05.000 INFO [executor-task-4]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791400542209, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873045000, receivedDispatcherTime=1739873042002, params=''} 2025-02-18 18:04:06.000 INFO [executor-task-5]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791408930817, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873046000, receivedDispatcherTime=1739873043002, params=''} 2025-02-18 18:04:07.000 INFO [executor-task-1]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791417319425, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873047000, receivedDispatcherTime=1739873044002, params=''} 2025-02-18 18:04:08.000 INFO [executor-task-2]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791425708033, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873048000, receivedDispatcherTime=1739873045002, params=''} 2025-02-18 18:04:09.000 INFO [executor-task-3]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791434096641, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873049000, receivedDispatcherTime=1739873046002, params=''} 2025-02-18 18:04:10.000 INFO [executor-task-4]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791434100737, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873050000, receivedDispatcherTime=1739873047002, params=''} 2025-02-18 18:04:11.000 INFO [executor-task-5]c.h.c.e.t.DemoCronTask - task handler..., params:TaskParams{page=1, total=1, taskLogId=6334722791450873857, taskId=6334721498112069633, method='cn.horace.cronjob.examples.tasks.DemoCronTask.handle', exeType=0, cron='* * * * * ?', tag='common', executionTime=1739873051000, receivedDispatcherTime=1739873048002, params=''} 5. 查看调度详情 至此，全部部署完成，可以愉快的玩耍了！应用内接入按照文档说明即可：请参考：快速开始。"},"title":"集群部署"},"/docs/deploy/self-build/":{"data":{"":"","#":"一、环境准备 1. 后端环境 Java版本：1.8+，官方用的是：1.8.0_391，64位。 Maven版本：3.9.8+，官方用的是：3.9.8。 2. 前端环境 安装Node.js：v18.20.4+，官方用的是：v18.20.4。 安装npm：10.7.0+，官方用的是：10.7.0。 安装yarn、tyarn，通过如下命令： npm install yarn tyarn -g 配置国内镜像 npm config set registry https://registry.npmmirror.com yarn config set registry https://registry.npmmirror.com 二、构建部署包 1. 源码下载 GitHub：https://github.com/horacedh/cron-job Gitee：https://gitee.com/horacedh/cron-job 2. 开始构建 在源代码目录下执行构建脚本，即可构建后端和前端 sh builder.sh 构建成功后会出现 build 目录，里边就是打包好之后的文件。 "},"title":"自行构建"},"/docs/manual/alarm_config/":{"data":{"":"","#":"一、前提条件 1、申请应用及权限 需要在Lark/飞书的开放平台中创建应用并添加机器人能力，然后获取应用的appId和appSecret，同时需要将机器人拉入告警群。 给刚刚新建的应用添加【应用身份】权限 获取群组信息 im:chat:readonly 获取与发送单聊、群组消息 im:message 2、调度器配置告警渠道 需要在调度器中配置告警渠道的appId和appSecret，方可在后台中选择对应的告警方式，application.properties配置内容如下：\n############# 告警配置 ############# # 调度平台域名，用于告警卡片的跳转 domain=http://localhost:8000 # 需要创建应用并给应用添加机器人能力，然后获取appId和appSecret，同时需要将机器人拉入告警群，之后获取应用的的appId和appSecret填入下面的配置中 # 飞书/Lark需要具备以下权限，注意的是【应用身份】权限 # 获取群组信息 im:chat:readonly # 获取与发送单聊、群组消息 im:message # Lark配置 lark.appId= lark.appSecret= # 飞书配置 feiShu.appId= feiShu.appSecret= ############# 告警配置 ############# 二、告警配置 目前告警配置基于租户级别，因此告警的配置对租户下的所有应用和任务生效。 告警方式的选择：需要先配置告警渠道，这里才能有的选择。 告警群组的选择：需要先将机器人拉入告警群，默认会拉取群创建时间倒排的100个群。 点击【触发一下】按钮可查看对应群的告警效果，以检查是否配置正确。 配置页面示例： 三、告警示例 点击【查看详情】可跳转到调度平台的任务详情页，查看错误堆栈。 application.properties的domain配置是跳转的前提，需要设定实际的调度平台域名。 "},"title":"告警配置"},"/docs/manual/app/":{"data":{"":"","#":"一、停止应用 停止应用时，会将应用下所有的任务停止，未被调度的任务将会取消。 "},"title":"应用管理"},"/docs/manual/config/":{"data":{"":"","#":"一、调度器完整配置 以下配置文件中包含了所有配置项，是经历过调优的最佳实践，使用时可以根据自己的需求场景修改。\n############# 调度器配置 ############# # 用于标识实例的唯一性 server.id=1 # 调度器提前调度时间，默认3000毫秒，用作在一些网络等延迟场景下提前调度，任务会先放入执行器内存队列，时间到达时才会真正执行 schedulers.beforeInterval=3000 # 调度器超时时间，调度器多久没心跳时则超时，单位毫秒 schedulers.timeout=30000 # 调度器每次从任务日志加载到内存队列的任务数量，如果任务量大，1秒内调度任务数多，则可以调高此值增加吞吐量，如果任务量少，此值过大会导致其他调度器拿不到调度任务，存在调度倾斜的问题 schedulers.taskQueueCount=10 # 调度器预生成任务日志的时候，只预生成生成配置值分钟以内的任务日志 schedulers.taskPreGenerationMaxTimeMinutes=3 # 任务日志、执行器记录、统计记录最大保留的天数 taskLog.maxRetainDays=5 # 管理后台与调度器通信的签名Key manager.signKey=6b540a079699b196d678af5801b79b4e # 执行器与调度器通信的签名Key executor.signKey=7d890a079948b196756rtf5452d2245t ############# 调度器配置 ############# ############# 执行器配置 ############# # 执行器的超时时间，超过这个时间没有心跳则认为是下线 executor.timeout=30000 # 如果所有的执行器离线太久，则自动停止应用，避免无意义的调度，单位分钟 executor.autoStopAppMinutes=15 ############# 执行器配置 ############# ############# 数据源配置 ############# database.driverClassName=com.mysql.cj.jdbc.Driver database.url=jdbc:mysql://localhost:3306/cron-job?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=false\u0026allowPublicKeyRetrieval=true database.username=horace database.password=SGJIWkjfdsof923847 # 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 database.initialSize=5 # 连接池最大连接数 database.maxActive=20 # 连接超时时间，毫秒 database.connectTimeout=3000 # 读取超时时间，毫秒 database.socketTimeout=5000 ############# 数据源配置 ############# ############# Tomcat配置 ############# # Tomcat服务配置 server.port=9527 # 当所有可能的请求处理线程都在使用时，传入连接请求的最大队列长度。 server.tomcat.accept-count=500 # 服务器在任何给定时间接受和处理的最大连接数。一旦达到限制，操作系统仍然可以根据“acceptCount”属性接受连接。 server.tomcat.max-connections=8192 # 任何HTTP post请求中表单内容的最大大小。 server.tomcat.max-http-form-post-size=2MB # 最大的工作线程数 server.tomcat.threads.max=600 # 最小工作线程数 server.tomcat.threads.min-spare=10 ############# Tomcat配置 ############# ############# 告警配置 ############# # 调度平台域名，用于告警卡片的跳转 domain=http://localhost:8000 # 需要创建应用并给应用添加机器人能力，然后获取appId和appSecret，同时需要将机器人拉入告警群，之后获取应用的的appId和appSecret填入下面的配置中 # 飞书/Lark需要具备以下权限，注意的是【应用身份】权限 # 获取群组信息 im:chat:readonly # 获取与发送单聊、群组消息 im:message # Lark配置 lark.appId= lark.appSecret= # 飞书配置 feiShu.appId= feiShu.appSecret= ############# 告警配置 ############# 二、管理后台UI配置 路径在cronjob-managerui/config/中：\ndefaultSettings.ts：管理后台UI的默认配置，其中signKey是管理后台UI与调度器通信的签名Key，如需自定义，则需要与管理后台UI的配置保持一致，修改配置需要自行构建。 其他一些配置如无特别需要，建议不做修改。 三、注意事项 server.id 是用于区分调度器唯一性的标识，必须保证唯一，否则后者启动会失败。 server.port 是调度器的通信端口，如果部署在同一台物理机，则需要修改端口。高可用角度讲，不建议多个调度器部署在同一台物理机。 数据库相关的，按照自己的实际情况修改即可。 manager.signKey：管理后台UI与调度器通信的签名Key，如需自定义，则需要与管理后台UI的配置保持一致，在cronjob-managerui/config/defaultSettings.ts中的signKey。 executor.signKey：执行器与调度器通信的签名Key，如需自定义，则需要与执行器的配置保持一致。 "},"title":"详细配置"},"/docs/manual/executor-sdk/":{"data":{"":"","#":"一、原生Java版本 1. 项目依赖 \u003c!-- https://mvnrepository.com/artifact/cn.horace.cronjob/cronjob-executor --\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.horace.cronjob\u003c/groupId\u003e \u003cartifactId\u003ecronjob-executor\u003c/artifactId\u003e \u003cversion\u003e最新版本\u003c/version\u003e \u003c/dependency\u003e 2. 启动类入口 原生版本的启动类入口为CronJobExecutorClient，使用方式如下：\n// taskObjects 为任务对象集合，原生Java版本需要手动放入一个集合中 ExecutorConfig config = ExecutorConfig.Builder.newBuilder(taskObjects) .address(\"http://127.0.0.1:9527\") // 调度器地址 .tenant(\"horace\") // 租户代码 .appName(\"example-executor\") // 应用名称 .appDesc(\"普通示例执行器\") // 应用描述 .tag(\"common\") // 标签 .build(); CronJobExecutorClient.init(config).start(); 二、SpringBoot版本 1. 项目依赖 \u003c!-- https://mvnrepository.com/artifact/cn.horace.cronjob/cronjob-executor-starter --\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.horace.cronjob\u003c/groupId\u003e \u003cartifactId\u003ecronjob-executor-starter\u003c/artifactId\u003e \u003cversion\u003e最新版本\u003c/version\u003e \u003c/dependency\u003e 2. 配置方式 代码配置，注意与原生版本的配置类不同，这里是ExecutorStarterConfig @Bean public ExecutorStarterConfig cronJobExecutorStarterConfig() { ExecutorStarterConfig config = new ExecutorStarterConfig(); config.setAddress(\"http://127.0.0.1:9527\"); config.setTenant(\"horace\"); config.setAppName(\"example-executor-starter\"); config.setAppDesc(\"Spring示例执行器\"); config.setTag(\"common\"); return config; } 配置文件配置，引入依赖后，即可直接在application.properties配置文件中配置，并且有智能提示 注意：代码配置优先于配置文件的配置，即有代码配置的情况下，配置文件的配置不生效。\n3. 启动方式 增加注解@EnableCronJob 启动Spring容器 详情参考：快速开始\n三、Go语言版本 1. 项目依赖 go get github.com/horacedh/cronjob-executor 2. 启动方式 type DemoTask struct { } // Handle 任务处理方法 func (d DemoTask) Handle(params *task.TaskParams) *task.HandlerResult { logger.Infof(\"task handle, params: %v\", utils.ToJsonString(params)) return task.Success() } func main() { // 创建执行器客户端 client := cronjob.GetExecutorClient(\u0026bean.ExecutorOptions{ Address: \"http://127.0.0.1:9527\", Tenant: \"horace\", AppName: \"go-example-executor\", AppDesc: \"Go示例执行器\", Tag: \"common\", SignKey: \"7d890a079948b196756rtf5452d2245t\", }) // 添加任务 client.AddTask(DemoTask{}, bean.TaskOptions{ Cron: \"* * * * * ? \", Name: \"Go测试任务\", }) // 启动执行器 client.Start() } 四、其他版本 正在规划中….Go、Shell等"},"title":"执行器SDK"},"/docs/manual/openapi/":{"data":{"":"","#":"一、介绍 这是调度平台开放出来提供给用户实现一些自定义功能的API，可根据此OpenAPI构建出自己的执行器，适用于官方未涉及的异构系统（官方已有Java和Go执行器）。\n二、接口签名 所有API都需要进行签名验证，包括执行器发请求给调度器，也包括调度器发请求给执行器，签名算法如下：\n待签名参数 signKey ：调度平台的密钥，需要保持与调度器一致。 times：请求时的时间戳，单位为毫秒级。 token：固定值为not-need-token，目前暂未使用。 rb：请求体的JSON字符串。 将待签名参数按照参数名的ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1\u0026key2=value2…）拼接成字符串stringA。 对字符串stringA进行MD5运算，得到字符串sign。 请求头增加Header参数： sign：签名字符串。 times：请求时的时间戳，单位为毫秒级。 token：固定值为not-need-token，目前暂未使用。 可参考Java的代码实现： https://github.com/HoraceDH/cron-job/blob/master/cronjob-commons/src/main/java/cn/horace/cronjob/commons/httpclient/DefaultRequestInterceptor.java 三、执行器相关API 公共请求头 参数名 参数值 备注 User-Agent CronJob-语言-SDK 例如：CronJob-Java-SDK Content-Type application/json; charset=utf-8 SDK-Version 执行器SDK版本 例如：Java-1.0.0 sign 签名后MD5字符串 上一步签名得到的值 times 请求时的时间戳 单位为毫秒级 token 固定值为not-need-token 预留，目前暂未使用 1. 注册执行器 POST /openapi/executor/register 以Body（entity）的方式提交参数，参数如下：\n请求内容 { \"tenant\" : \"horace\", // 租户编码 \"appName\" : \"go-example-executor\", // 应用名称 \"appDesc\" : \"Go示例执行器\", // 应用描述 \"hostName\" : \"HoraceiMacProMax.local\", // 主机名称 \"tag\" : \"common\", // 执行器标签 \"version\" : \"Go-1.0.0\", // 执行器SDK版本 \"address\" : \"192.168.16.51:8527\" // 执行器WEB端口地址 } 响应内容 code = 0 表示成功，其他表示失败 {\"code\": 0, \"msg\": \"\"} 2. 注销执行器 POST /openapi/executor/unregister\n3. 注册任务 POST /openapi/task/register 以Body（entity）的方式提交参数，参数如下：\n请求内容 [ { \"appDesc\" : \"Go示例执行器\", // 应用描述 \"appName\" : \"go-example-executor\", // 应用名称 \"cron\" : \"* * * * * ? \", // Cron表达式 \"expiredStrategy\" : 2, // 过期策略 \"expiredTime\" : 180000, // 过期时间 \"failureRetryInterval\" : 5000, // 失败重试间隔 \"failureStrategy\" : 1, // 失败策略 \"maxRetryCount\" : 5, // 最大重试次数 \"method\" : \"go-example-executor/main.DemoTask.Handle\", // 任务方法标识 \"name\" : \"Go测试任务\", // 任务名称 \"remark\" : \"\", // 任务备注 \"routerStrategy\" : 1, // 路由策略 \"tag\" : \"common\", // 任务标签 \"tenant\" : \"horace\", // 租户编码 \"timeout\" : 10000 // 超时时间 } ] 响应内容 code = 0 表示成功，其他表示失败 {\"code\": 0, \"msg\": \"\"} 4. 执行器心跳 POST /openapi/executor/heartbeat 以Body（entity）的方式提交参数，参数如下：\n请求内容 { \"address\" : \"192.168.16.51:8527\" // 执行器WEB端口地址 } 响应内容 code = 0 表示成功，其他表示失败 {\"code\": 0, \"msg\": \"\"} 5. 任务完成回调 POST /openapi/task/complete 以Body（entity）的方式提交参数，参数如下：\n请求内容 { \"taskLogId\": 0, // 任务日志ID \"taskId\": 0, // 任务ID \"state\": 4, // 任务执行状态 \"failedReason\": \"\", // 失败原因 \"realExecutionTime\": 0, // 实际执行时间，毫秒级时间戳 \"elapsedTime\": 0, // 任务执行耗时 \"address\": \"127.0.0.1:8527\" // 执行器地址 } 响应内容 code = 0 表示成功，其他表示失败 {\"code\": 0, \"msg\": \"\"} 6. 调度器派发任务给执行器 POST /dispatch 以Body（entity）的方式提交参数，参数如下：\n{ \"page\": 1, // 分页页码 \"total\": 1, // 总页数 \"taskLogId\": 6376237640206782465, // 任务日志ID \"taskId\": 6372593233301606401, // 任务ID \"method\": \"go-example-executor/main.DemoTask.Handle\", // 任务方法标识 \"exeType\": 0, // 执行类型 \"cron\": \"* * * * * ?\", // Cron表达式 \"tag\": \"\", // 任务标签 \"executionTime\": 1744822072000, // 执行时间 \"params\": \"\" // 任务参数 } 响应内容 code = 0 表示成功，其他表示失败 {\"code\": 0, \"msg\": \"\"} 7. 具体细节可参考Java的执行器实现 https://github.com/HoraceDH/cron-job/tree/master/cronjob-executor "},"title":"OpenAPI"},"/docs/manual/task/":{"data":{"":"","#":"一、操作界面 启动、停止：表示启动和停止任务，这两个按钮是互斥的，同一状态下只会出现一个。 执行：只会执行一次，但不会启动任务，适用于需要手动触发一次的场景，并且可以设定参数。 编辑：进入任务的编辑页面。 日志：查看当前任务已经执行成功的任务日志。 详情：查看任务的详情信息。 标签列：任务的标签，方便用户对任务进行分类管理，测试环境多迭代场景下，可通过给任务配置Tag标签，实现任务路由到不同的执行器上。 二、编辑任务 内置了Cron表达式编辑器，免去了跳转到第三方网站编辑的麻烦，并且实时展示最近的执行时间。 "},"title":"任务管理"},"/docs/manual/tasklog/":{"data":{"":"","#":"一、任务日志列表 默认情况下，只查询最近30分钟的任务日志，可点击【展开】筛选更多查询项。 查询范围最大只支持3小时内的查询范围，如果要查询更多时间的范围，需要手动选择时间，避免大范围查询的性能问题。 二、任务日志详情 任务日志状态说明：\n初始化：任务日志创建成功，等待调度器派发。 队列中：任务日志已被调度器放入内存队列，等待调度器派发给执行器执行。 调度中：任务日志已被调度器派发给执行器，等待执行器执行的结果。 执行成功：任务执行成功，任务日志已被执行器返回。 执行失败：任务执行失败，可在详情中查看详细原因。 取消执行：一般是调度前修改了任务详情，或者停止了应用，则会被取消。 任务过期：任务已经超过了调度时间，并且过期策略是丢弃，表示任务日志已被丢弃。 执行失败，已丢弃：任务执行失败，并且失败策略是丢弃，表示任务日志已被丢弃。 执行失败，重试中：表示上一次任务执行失败，正在重试中。 "},"title":"任务日志管理"},"/docs/manual/user/":{"data":{"":"","#":"一、创建用户 二、授权菜单 菜单权限控制到接口级别，可按需开权限 三、授权租户 "},"title":"用户管理"},"/docs/overview/":{"data":{"":"","#":"一、介绍 1. Cron-Job Cron-Job 分布式任务调度平台是一种用于管理微服务系统中定时任务的软件系统，它提供了一种简单易用、超低延迟、支持用户权限管理、多语言客户端和多租户接入的方式来高效调度和执行任务。\n2. 技术栈 Cron-Job 分布式任务调度平台是前后端分离的架构，服务端基于Java语言开发，前端基于Ant Design Pro开发，采用互联网主流技术栈构建而成。涉及的主要技术栈有：\n服务端：MySQL、Druid、MyBatis、MyBatis-Generator、HttpClient、Spring Boot等。 前端：React、Ant Design Pro、Ant Design Charts、Babel、Eslint、Axios等。 3. 基本概念 租户：租户是指系统中不同的业务方，每个租户在Cron-Job中拥有独立的权限管理和资源隔离。 调度器：调度器是指系统中负责任务调度的服务，它可以根据任务的配置信息，在指定的时间点派发任务给执行器。 应用：应用是接入方的一个微服务，它受调度器的调度，一个应用下一般有多个实例。 执行器：执行器是应用的一个实例，负责执行任务的具体逻辑，一个应用下一般有多个执行器。 任务：任务是指系统中最小的执行单元，它可以通过配置在某个特定的时间点触发任务执行。 任务日志：任务日志是指系统中某一次任务的执行日志，他涵盖了这个任务派发给了哪个执行器，什么时候执行的，耗费了多少时间等等信息。 5. 适用场景 适用于一切可以被cron表达式定义时间点的任务场景，例如：\n定时计算、统计报表 定时推送信息 定时结算 订单超时自动取消 批量分片处理等等 二、解决了什么问题 假如有一个需求，需要每天凌晨1点执行一次统计任务，一般是使用分布式锁（Redis、ZK、MySQL）等方式，保证同一时刻只有一个任务执行。整个应用中如果有多个这类任务则需要重复维护，如果扩大到整个公司的业务来看，效率将是低下的，并且以下诉求很难得到满足：\n不支持任务参数的动态调整，例如某类任务需要根据特定参数做一些特性化事情的时候。 不支持分片任务，例如某类任务需要处理的数据量很大，需要分片处理，多个系统之间的协调也是难点。 较难失败重试，或失效转移，例如执行失败之后，需要重试或转移到其他节点执行。 任务执行数据难以统计，任务的执行的耗时、失败次数、执行次数等，都难以统计。 不支持任务的停止，例如在机房迁移等一些场景，需要暂时性的停止任务。 在不适用分布式调度平台的情况，不同语言的应用需要单独再实现一遍，效率低下。 但是 Cron-Job 可以很好的解决这些问题，并且接入简单、超低延迟、可靠性高，使用起来非常方便。\n三、核心优势 现代化的管理后台UI更加精美简洁，并优化了管理后台的交互逻辑，理解和使用更加简单。 基于提前调度的策略，避免了网络延迟的问题，任务的调度更加精准。 支持多租户接入以及用户权限管理，多业务情况下以不同租户接入，互不干扰。 支持任务级别的标签路由能力，测试环境多迭代下可指定路由到不同标签的执行器。 执行器和调度器都支持无损的优雅停机，队列中的任务不会丢失，执行器的结果不会丢失。 支持任务失败告警，当前支持飞书、Lark告警，未来会支持更多的告警方式。 支持慢SQL监控，超过1秒的SQL，会被记录到错误日志中，方便用户排查问题。 用户的接入和使用更加高效简单，代码上打上注解，就可以完成自动注册，不需要额外的配置。 简单而恰到好处的架构设计，尽量少的三方依赖，避免了复杂的集群选举和负载均衡策略。 支持集群的横向扩展能力，多节点可平摊调度压力，可动态无损的增删调度节点，无需担心任务丢失。 开放OpenAPI，支持用户自定义执行器，可根据需要构建其他语言的执行器，目前官方支持Java和Go。 四、基本架构 1. 模块架构 2. 部署架构 3. 调度器的依赖 调度器仅依赖于MySQL数据库，除此之外不依赖于任何第三方服务，部署成本低。 有朋友会说，强依赖于MySQL，性能和可靠性受MySQL制约，先试想一下，你的业务系统是不是强依赖于MySQL？换句话说，他在99%的互联网场景中，完全够用。 五. 产品特性 1. 功能 任务调度： 支持cron表达式的任务调度，支持分片和随机策略。 路由策略： 随机策略：随机选择一个执行器执行任务，适用于多实例之间互斥的任务场景。 分片策略：动态任务分片，每个分片由一个执行器执行，适用于大批量计算任务场景。 过期策略： 过期丢弃：任务超过执行时间后而未被调度则直接丢弃，适用于任务密集型场景，一般不会出现超过时间而未被调度的情况。 过期执行：任务超过执行时间后，仍然由调度器调度，适用于任务松散型场景，例如1天才执行一次的任务，或者一个月才执行的任务。 失败策略： 失败丢弃：任务执行失败后，丢弃任务，适用于任务执行不敏感的场景。 失败重试：任务执行失败后，重试任务，可配置重试时间和重试次数，适用于任务执行失败后需要重新执行的场景。 任务超时：执行器接收到任务请求后，如果未在固定时间内反馈结果，会认为是超时，则按失败策略处理。 任务参数： 支持任务参数的动态调整，例如某类任务需要根据特定参数做一些特性化事情的时候。 任务标签： 提供任务标签的功能，方便用户对任务进行分类管理，测试环境多迭代场景下，可通过给任务配置Tag标签，实现任务路由到不同的执行器上。 数据清理： 可配置调度日志、报表等数据的保留时间，避免数据量一直增长。 2. 效率 用户体验与效率： 让用户的接入更加简单，只需要代码上打上注解，就可以完成自动注册，不需要额外的配置，只需要点击开始即可。 现代化的管理后台UI更加精美简洁，并优化了管理后台的交互逻辑，理解和使用更加简单。 更加全面且有结构化的官方文档，尽可能让用户一目了然，自主接入和部署，而不需要过多研究和提问。 问题的排查效率： 管理后台提供更多维度的日志详情，能够帮助用户更好的理解任务的执行情况，并且能够更好的排查问题。 3. 性能与扩展性 毫秒级的调度延迟： 基于提前调度策略，抹平服务器时间差、网络延迟等因素，使任务的执行更加及时，实际测试为个位数毫秒级别（执行器的GC和性能）。 基于ACK确认、失败重试、过期调度等策略，使任务的执行更加准确、可靠，当然也可以通过配置不要失败重试。 可靠的调度结果： 任务执行后，无论是否成功，都会反馈调度结果给调度器，失败会一直重试，保证结果的可靠性。 高可用的调度服务： 支持集群部署，支持高可用的调度服务。 支持动态扩缩容，运行情况下，动态增删调度节点，不影响任务的执行和调度。 4. 可视化与告警 任务报表，提供任务执行的统计报表，包括任务的执行次数、失败次数、执行耗时、平均执行耗时等。 任务告警，提供任务执行的告警功能，支持飞书、Lark等多种告警方式，未来可接入更多告警方式。 5. 安全性 精心设计权限管理的功能，可控制到接口的权限级别，任务的安全性更加可靠，多租户间权限隔离。 后台管理接口的交互、执行器和调度器之间的openApi交互，均采用签名校验机制，避免参数篡改、伪造和重放等问题。 六、管理平台界面 管理平台主页： 任务日志详情： "},"title":"概述"},"/docs/quickstart/":{"data":{"":"","#":"一、原生Java版本 1. 引入maven依赖 \u003c!-- 同时提供有Gradle等各类依赖类型 https://mvnrepository.com/artifact/cn.horace.cronjob/cronjob-executor --\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.horace.cronjob\u003c/groupId\u003e \u003cartifactId\u003ecronjob-executor\u003c/artifactId\u003e \u003cversion\u003e最新版本\u003c/version\u003e \u003c/dependency\u003e 2. 实现任务处理接口 /** * 演示任务 * Created in 2025-01-01 10:44. * * @author Horace */ @TaskConfig(name = \"普通测试任务\", cron = \"* * * * * ? \", routerStrategy = RouterStrategy.RANDOM) public class DemoCronTask implements TaskHandler { private static final Logger logger = LoggerFactory.getLogger(DemoCronTask.class); /** * 执行任务的方法 * * @param params 任务参数 * @return 任务执行结果，如果执行成功，则返回HandlerResult.success()，如果执行失败，则返回HandlerResult.fail()，返回null，也判定是失败 */ @Override public HandlerResult handle(TaskParams params) { logger.info(\"task handler..., params:{}\", params); Random random = new Random(); int delay = random.nextInt(50); LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(delay)); return HandlerResult.success(); } } 3. 新建启动类 /** * 示例执行器 * \u003cp\u003e * * @author Horace */ public class ExampleExecutor { private static final Logger logger = LoggerFactory.getLogger(ExampleExecutor.class); public static void main(String[] args) { ArrayList\u003cObject\u003e taskObjects = new ArrayList\u003c\u003e(); taskObjects.add(new DemoCronTask()); ExecutorConfig config = ExecutorConfig.Builder.newBuilder(taskObjects) .address(\"http://127.0.0.1:9527\") .tenant(\"horace\") .appName(\"example-executor\") .appDesc(\"普通示例执行器\") .tag(\"common\") .signKey(\"7d890a079948b196756rtf5452d2245t\") .build(); CronJobExecutorClient.init(config).start(); } } address：这里指定的是调度器的地址，如果是本地单节点测试，则指定地址+端口的方式是；如果是线上集群部署，则指定的是Nginx地址。 tenant：租户的代码，一般是租户的英文名称。 appName：应用名称，一般是应用的英文名称。 appDesc：应用描述，应用的中文描述，后续在管理平台中可以看到。 tag：标签，用于区分同个应用下的不同执行器，如无需求，则不配置即可。 signKey：签名密钥，用于验证执行器的身份，必须和调度器配置的签名密钥一致。 二、SprintBoot版本 1. 引入maven依赖 \u003c!-- 同时提供有Gradle等各类依赖类型 https://mvnrepository.com/artifact/cn.horace.cronjob/cronjob-executor-starter --\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.horace.cronjob\u003c/groupId\u003e \u003cartifactId\u003ecronjob-executor-starter\u003c/artifactId\u003e \u003cversion\u003e最新版本\u003c/version\u003e \u003c/dependency\u003e 2. 实现任务处理接口 /** * 演示任务 * * @author Horace */ @Component @TaskConfig(name = \"Spring测试任务\", cron = \"* * * * * ? \", routerStrategy = RouterStrategy.RANDOM) public class DemoCronTask implements TaskHandler { private static final Logger logger = LoggerFactory.getLogger(DemoCronTask.class); /** * 执行任务的方法 * * @param params 任务参数 * @return 任务执行结果，如果执行成功，则返回HandlerResult.success()，如果执行失败，则返回HandlerResult.fail()，返回null，也判定是失败 */ @Override public HandlerResult handle(TaskParams params) { logger.info(\"task handler..., params:{}\", params); Random random = new Random(); int delay = random.nextInt(200); LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(delay)); return HandlerResult.success(); } } 注意：这里的任务类一定要打上Spring的注解，可以是@Component，把对象实例交给Spring管理。\n3. 新建配置类 /** * Created in 2025-01-01 21:00. * * @author Horace */ @Configuration public class AppConfig { private static final Logger logger = LoggerFactory.getLogger(AppConfig.class); /** * 自定义配置 * * @return */ @Bean public ExecutorStarterConfig cronJobExecutorStarterConfig() { ExecutorStarterConfig config = new ExecutorStarterConfig(); config.setAddress(\"http://127.0.0.1:9527\"); config.setTenant(\"horace\"); config.setAppName(\"example-executor-starter\"); config.setAppDesc(\"Spring示例执行器\"); config.setTag(\"common\"); config.setSignKey(\"7d890a079948b196756rtf5452d2245t\"); return config; } } 4. 新建启动类 /** * Created in 2025-01-01 21:00. * * @author Horace */ @EnableCronJob @SpringBootApplication public class ExampleSpringExecutor { private static final Logger logger = LoggerFactory.getLogger(ExampleSpringExecutor.class); public static void main(String[] args) { SpringApplication.run(ExampleSpringExecutor.class, args); } } 注意：需要在启动类上加上@EnableCronJob注解，开启CronJob的自动配置。\n三、Go语言版本 1. 引入github依赖 go get github.com/horacedh/cronjob-executor 2. 实现任务处理接口 // DemoTask 示例任务对象 type DemoTask struct { } // Handle 任务处理方法 func (d DemoTask) Handle(params *task.TaskParams) *task.HandlerResult { logger.Infof(\"task handle, params: %v\", utils.ToJsonString(params)) return task.Success() } 3. 启动执行器 func main() { // 创建执行器客户端 client := cronjob.GetExecutorClient(\u0026bean.ExecutorOptions{ Address: \"http://127.0.0.1:9527\", Tenant: \"horace\", AppName: \"go-example-executor\", AppDesc: \"Go示例执行器\", Tag: \"common\", SignKey: \"7d890a079948b196756rtf5452d2245t\", }) // 添加任务 client.AddTask(DemoTask{}, bean.TaskOptions{ Cron: \"* * * * * ? \", Name: \"Go测试任务\", }) // 启动执行器 client.Start() } "},"title":"快速开始"},"/docs/version/":{"data":{"":"","#":"版本 v1.0.9 规划 版本描述 【优化】提升超大任务量场景下的处理性能。 2025-04-16 版本 v1.0.8 版本描述 【优化】每次注册执行器时都将应用置为启用状态。 【优化】告警卡片标题添加任务名称。 【BugFix】解决TaskParams中接收时间错误的问题。 【新增】新增Go语言执行器SDK，接入指引请看：Go执行器接入 升级指引 如果你是从 v1.0.7 的版本升级到 v1.0.8，需要注意以下几点 无数据库、配置等变更，更新cronjob-scheduler即可。 cronjob-managerui有变更，需要同步更新，将旧文件全部删除，然后将新文件复制过来。 cronjob-executor有变更，需要升级到最新版本。 如果你是首次使用该版本，则可以无视这个升级指引。 2025-03-23 版本 v1.0.7 版本描述 【优化】告警方法放入线程池中执行 【优化】请求签名去除无用字段，减少请求参数大小。 升级指引 如果你是从 v1.0.6 的版本升级到 v1.0.7，需要注意以下几点 无数据库、配置等变更，更新cronjob-scheduler即可。 cronjob-managerui无变更。 如果你是首次使用该版本，则可以无视这个升级指引。 2025-03-22 版本 v1.0.6 版本描述 【优化】优化管理后台页面展示 【优化】任务日志详情页面增加执行器主机名字段。 【BugFix】修复调度大盘中数据指标的任务选择名称取错的问题。 【新增】大盘展示告警概要列表，可点击查看告警详情。 【新增】增加任务失败告警能力，并对接飞书、Lark。 升级指引 如果你是从 v1.0.5 的版本升级到 v1.0.6，需要注意以下几点 增加告警记录表 # 告警记录表 create table `t_alarm` ( `id` bigint primary key comment '主键', `task_log_id` bigint unique not null comment '任务日志ID', `app_name` varchar(100) not null comment '应用名', `task_name` varchar(100) not null comment '任务名', `executor_address` varchar(50) not null comment '执行器地址', `executor_host_name` varchar(100) comment '执行器主机名', `method` varchar(500) not null comment '任务方法，类全限定名', `alarm_type` int not null default 0 comment '告警方式，AlarmType枚举', `state` int not null default 0 comment '告警状态，AlarmState枚举', `alarm_group_name` varchar(200) default '' comment '告警群名称', `create_time` datetime(3) not null default current_timestamp(3) comment '创建时间', `modify_time` datetime(3) not null default current_timestamp(3) comment '修改时间' on update current_timestamp(3), index idx_app_name(`app_name`), index idx_task_name(`task_name`), index idx_create_time(`create_time`) ) comment '告警记录表'; 修改tenant表，新增alarm_config字段 # 任务日志表增加执行器主机名 alter table `t_tenant` add `alarm_config` varchar(500) not null default '{\"chatId\":\"不设置告警\",\"type\":0}' comment '告警配置，json格式' after `tenant`; 新增告警配置 ############# 告警配置 ############# # 调度平台域名，用于告警卡片的跳转 domain=http://localhost:8000 # 需要创建应用并给应用添加机器人能力，然后获取appId和appSecret，同时需要将机器人拉入告警群，之后获取应用的的appId和appSecret填入下面的配置中 # 飞书/Lark需要具备以下权限，注意的是【应用身份】权限 # 获取群组信息 im:chat:readonly # 获取与发送单聊、群组消息 im:message # Lark配置 lark.appId= lark.appSecret= # 飞书配置 feiShu.appId= feiShu.appSecret= ############# 告警配置 ############# cronjob-managerui有变更，需要同步更新，将旧文件全部删除，然后将新文件复制过来。 如果你是首次使用该版本，则可以无视这个升级指引。 2025-03-02 版本 v1.0.5 版本描述 任务列表操作列增加【日志】按钮，可快捷查看调度成功的任务日志记录。 解决停止任务后立马又启动时，任务调度不连续的问题。 调度大盘的折线图统计数据，增加任务维度的筛选。 任务的调度，增加Tag标签路由的功能，测试环境多迭代场景下，可通过给任务配置Tag标签，实现任务路由到不同的执行器上。 升级指引 如果你是从 v1.0.4 的版本升级到 v1.0.5，需要注意以下几点 增加任务维度的统计数据表 # 任务级别统计数据表 create table `t_task_statistics` ( `date_scale` datetime(3) comment '统计时间，分钟级', `task_id` bigint not null comment '任务ID', `task_name` varchar(100) not null comment '任务名', `scheduler_success` int default 0 comment '调度成功', `scheduler_failed` int default 0 comment '调度失败', `delay_avg` double(10, 2) default 0 comment '平均延迟', `delay_max` double(10, 2) default 0 comment '最大延迟', `delay_min` double(10, 2) default 0 comment '最小延迟', `elapsed_avg` double(10, 2) default 0 comment '平均耗时', `elapsed_max` double(10, 2) default 0 comment '最大耗时', `elapsed_min` double(10, 2) default 0 comment '最小耗时', `before_avg` double(10, 2) default 0 comment '平均提前调度时间，毫秒', `before_max` double(10, 2) default 0 comment '最大提前调度时间，毫秒', `before_min` double(10, 2) default 0 comment '最小提前调度时间，毫秒', `create_time` datetime(3) not null default current_timestamp(3) comment '创建时间', `modify_time` datetime(3) not null default current_timestamp(3) comment '修改时间' on update current_timestamp(3), primary key (`date_scale`, `task_id`) ) comment '任务级别统计数据表'; 任务日志表增加执行器的主机名字段 # 任务日志表增加执行器主机名 alter table t_task_log add column `executor_host_name` varchar(100) comment '主机名' after `executor_address`; cronjob-managerui有变更，需要同步更新，将旧文件全部删除，然后将新文件复制过来。 如果你是首次使用该版本，则可以无视这个升级指引。 2025-02-22 版本 v1.0.4 版本描述 记录管理后台操作日志，方便事后回溯操作行为。 如果一段时间内没有任何在线的执行器，就停止该应用，避免无意义调度 升级指引 如果你是从 v1.0.3 以及之前的版本升级到 v1.0.4，需要注意以下几点 在 application.properties 中手动添加以下配置： # 如果所有的执行器离线太久，则自动停止应用，避免无意义的调度，单位分钟 executor.autoStopAppMinutes=15 cronjob-managerui有变更，需要同步更新，将旧文件全部删除，然后将新文件复制过来。 如果你是首次使用该版本，则可以无视这个升级指引。 2025-02-18 版本 v1.0.2 修改相关描述信息。 2025-02-15 版本 v1.0.1 Cron-Job分布式任务调度平台首次发布。 包含完整的调度能力。 "},"title":"更新记录"}}